package models

import "strings"


// Copyright (c) HashiCorp Inc. All rights reserved.
// Licensed under the MIT License. See NOTICE.txt in the project root for license information.



type UpdateAllowedCombinationsResultPreviousCombinations string

const (
	UpdateAllowedCombinationsResultPreviousCombinationsdeviceBasedPush UpdateAllowedCombinationsResultPreviousCombinations = "DeviceBasedPush"
	UpdateAllowedCombinationsResultPreviousCombinationsemail UpdateAllowedCombinationsResultPreviousCombinations = "Email"
	UpdateAllowedCombinationsResultPreviousCombinationsfederatedMultiFactor UpdateAllowedCombinationsResultPreviousCombinations = "FederatedMultiFactor"
	UpdateAllowedCombinationsResultPreviousCombinationsfederatedSingleFactor UpdateAllowedCombinationsResultPreviousCombinations = "FederatedSingleFactor"
	UpdateAllowedCombinationsResultPreviousCombinationsfido2 UpdateAllowedCombinationsResultPreviousCombinations = "Fido2"
	UpdateAllowedCombinationsResultPreviousCombinationshardwareOath UpdateAllowedCombinationsResultPreviousCombinations = "HardwareOath"
	UpdateAllowedCombinationsResultPreviousCombinationsmicrosoftAuthenticatorPush UpdateAllowedCombinationsResultPreviousCombinations = "MicrosoftAuthenticatorPush"
	UpdateAllowedCombinationsResultPreviousCombinationspassword UpdateAllowedCombinationsResultPreviousCombinations = "Password"
	UpdateAllowedCombinationsResultPreviousCombinationssms UpdateAllowedCombinationsResultPreviousCombinations = "Sms"
	UpdateAllowedCombinationsResultPreviousCombinationssoftwareOath UpdateAllowedCombinationsResultPreviousCombinations = "SoftwareOath"
	UpdateAllowedCombinationsResultPreviousCombinationstemporaryAccessPassMultiUse UpdateAllowedCombinationsResultPreviousCombinations = "TemporaryAccessPassMultiUse"
	UpdateAllowedCombinationsResultPreviousCombinationstemporaryAccessPassOneTime UpdateAllowedCombinationsResultPreviousCombinations = "TemporaryAccessPassOneTime"
	UpdateAllowedCombinationsResultPreviousCombinationsvoice UpdateAllowedCombinationsResultPreviousCombinations = "Voice"
	UpdateAllowedCombinationsResultPreviousCombinationswindowsHelloForBusiness UpdateAllowedCombinationsResultPreviousCombinations = "WindowsHelloForBusiness"
	UpdateAllowedCombinationsResultPreviousCombinationsx509CertificateMultiFactor UpdateAllowedCombinationsResultPreviousCombinations = "X509CertificateMultiFactor"
	UpdateAllowedCombinationsResultPreviousCombinationsx509CertificateSingleFactor UpdateAllowedCombinationsResultPreviousCombinations = "X509CertificateSingleFactor"
)


func PossibleValuesForUpdateAllowedCombinationsResultPreviousCombinations() []string {
	return []string{
		string(UpdateAllowedCombinationsResultPreviousCombinationsdeviceBasedPush),
string(UpdateAllowedCombinationsResultPreviousCombinationsemail),
string(UpdateAllowedCombinationsResultPreviousCombinationsfederatedMultiFactor),
string(UpdateAllowedCombinationsResultPreviousCombinationsfederatedSingleFactor),
string(UpdateAllowedCombinationsResultPreviousCombinationsfido2),
string(UpdateAllowedCombinationsResultPreviousCombinationshardwareOath),
string(UpdateAllowedCombinationsResultPreviousCombinationsmicrosoftAuthenticatorPush),
string(UpdateAllowedCombinationsResultPreviousCombinationspassword),
string(UpdateAllowedCombinationsResultPreviousCombinationssms),
string(UpdateAllowedCombinationsResultPreviousCombinationssoftwareOath),
string(UpdateAllowedCombinationsResultPreviousCombinationstemporaryAccessPassMultiUse),
string(UpdateAllowedCombinationsResultPreviousCombinationstemporaryAccessPassOneTime),
string(UpdateAllowedCombinationsResultPreviousCombinationsvoice),
string(UpdateAllowedCombinationsResultPreviousCombinationswindowsHelloForBusiness),
string(UpdateAllowedCombinationsResultPreviousCombinationsx509CertificateMultiFactor),
string(UpdateAllowedCombinationsResultPreviousCombinationsx509CertificateSingleFactor),
	}
}



func parseUpdateAllowedCombinationsResultPreviousCombinations(input string) (*UpdateAllowedCombinationsResultPreviousCombinations, error) {
	vals := map[string]UpdateAllowedCombinationsResultPreviousCombinations{
		"devicebasedpush": UpdateAllowedCombinationsResultPreviousCombinationsdeviceBasedPush,
"email": UpdateAllowedCombinationsResultPreviousCombinationsemail,
"federatedmultifactor": UpdateAllowedCombinationsResultPreviousCombinationsfederatedMultiFactor,
"federatedsinglefactor": UpdateAllowedCombinationsResultPreviousCombinationsfederatedSingleFactor,
"fido2": UpdateAllowedCombinationsResultPreviousCombinationsfido2,
"hardwareoath": UpdateAllowedCombinationsResultPreviousCombinationshardwareOath,
"microsoftauthenticatorpush": UpdateAllowedCombinationsResultPreviousCombinationsmicrosoftAuthenticatorPush,
"password": UpdateAllowedCombinationsResultPreviousCombinationspassword,
"sms": UpdateAllowedCombinationsResultPreviousCombinationssms,
"softwareoath": UpdateAllowedCombinationsResultPreviousCombinationssoftwareOath,
"temporaryaccesspassmultiuse": UpdateAllowedCombinationsResultPreviousCombinationstemporaryAccessPassMultiUse,
"temporaryaccesspassonetime": UpdateAllowedCombinationsResultPreviousCombinationstemporaryAccessPassOneTime,
"voice": UpdateAllowedCombinationsResultPreviousCombinationsvoice,
"windowshelloforbusiness": UpdateAllowedCombinationsResultPreviousCombinationswindowsHelloForBusiness,
"x509certificatemultifactor": UpdateAllowedCombinationsResultPreviousCombinationsx509CertificateMultiFactor,
"x509certificatesinglefactor": UpdateAllowedCombinationsResultPreviousCombinationsx509CertificateSingleFactor,
	}
	if v, ok := vals[strings.ToLower(input)]; ok {
		return &v, nil
	}

	// otherwise presume it's an undefined value and best-effort it
	out := UpdateAllowedCombinationsResultPreviousCombinations(input)
	return &out, nil
}
